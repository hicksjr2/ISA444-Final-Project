! pip install TimeCopilot
import pandas as pd

from timecopilot import TimeCopilotForecaster
from timecopilot.models.foundation.chronos import Chronos
from timecopilot.models.foundation.moirai import Moirai
from timecopilot.models.foundation.timesfm import TimesFM
from timecopilot.models.stats import AutoARIMA, SeasonalNaive

from functools import partial
from utilsforecast.evaluation import evaluate
from utilsforecast.losses import mase, scaled_crps

# Load your Nixtla/TimeCopilot-format panel
df = pd.read_csv("downsampled_df.csv", parse_dates=["ds"])

print(df.head())
print("Number of series:", df["unique_id"].nunique())

TimeCopilotForecaster.plot(df)

tcf = TimeCopilotForecaster(
    models=[
        AutoARIMA(),
        Chronos(repo_id="amazon/chronos-bolt-small"),
        Moirai(),
        TimesFM(repo_id="google/timesfm-2.5-200m-pytorch", alias="TimesFM-2.5"),
        TimesFM(repo_id="google/timesfm-2.0-500m-pytorch", alias="TimesFM-2.0"),
        SeasonalNaive(season_length=52),  # weekly data ≈ yearly seasonality
    ]
)

level = [0, 20, 40, 60, 80]

cv_df = tcf.cross_validation(
    df=df,
    h=12,         # 12 weeks ahead
    level=level,
    freq="W-FRI"  # Friday weekly data
)

tcf.plot(
    df,
    cv_df.drop(columns=["cutoff", "y"]),
    level=[40, 60, 80]
)

# Determine training period based on the first cutoff used in cross-validation
first_cutoff = cv_df["cutoff"].min()

train_df = df[df["ds"] <= first_cutoff]
print("Train period ends at:", first_cutoff)

eval_df = evaluate(
    cv_df.drop(columns=["cutoff"]),
    train_df=df,
    metrics=[partial(mase, seasonality=52), scaled_crps], # weekly seasonality ≈ 52
    level=level,
)

summary = (
    eval_df.groupby("metric")
           .mean(numeric_only=True)
           .T
           .sort_values(by="scaled_crps")
           .round(3)
)

print(summary)
